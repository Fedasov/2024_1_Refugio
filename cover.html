
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>mail: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">mail/cmd/mail/main.go (0.0%)</option>
				
				<option value="file1">mail/docs/docs.go (0.0%)</option>
				
				<option value="file2">mail/pkg/delivery/converters/email_converter.go (100.0%)</option>
				
				<option value="file3">mail/pkg/delivery/converters/user_converter.go (50.0%)</option>
				
				<option value="file4">mail/pkg/delivery/email/email_handler.go (82.1%)</option>
				
				<option value="file5">mail/pkg/delivery/middleware/auth.go (100.0%)</option>
				
				<option value="file6">mail/pkg/delivery/response.go (100.0%)</option>
				
				<option value="file7">mail/pkg/delivery/session/manager.go (92.3%)</option>
				
				<option value="file8">mail/pkg/delivery/session/session.go (100.0%)</option>
				
				<option value="file9">mail/pkg/delivery/user/user_handler.go (56.6%)</option>
				
				<option value="file10">mail/pkg/repository/converters/email_converter.go (100.0%)</option>
				
				<option value="file11">mail/pkg/repository/converters/user_converter.go (100.0%)</option>
				
				<option value="file12">mail/pkg/repository/email/email_repo.go (90.0%)</option>
				
				<option value="file13">mail/pkg/repository/user/user_repo.go (85.5%)</option>
				
				<option value="file14">mail/pkg/usecase/email/email_service.go (100.0%)</option>
				
				<option value="file15">mail/pkg/usecase/user/user_service.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "github.com/rs/cors"
        "mail/pkg/delivery/session"
        "net/http"

        emailHand "mail/pkg/delivery/email"
        userHand "mail/pkg/delivery/user"
        emailRepo "mail/pkg/repository/email"
        userRepo "mail/pkg/repository/user"
        emailUc "mail/pkg/usecase/email"
        userUc "mail/pkg/usecase/user"

        "github.com/gorilla/mux"
        httpSwagger "github.com/swaggo/http-swagger/v2"
        _ "mail/docs"
)

// @title API Mail
// @version 1.0
// @description API server for mail

// @host localhost:8080
// @BasePath /
func main() <span class="cov0" title="0">{
        sessionsManager := session.NewSessionsManager()

        emailRepository := emailRepo.NewEmailMemoryRepository()
        emailUseCase := emailUc.NewEmailUseCase(emailRepository)

        userRepository := userRepo.NewInMemoryUserRepository()
        userUseCase := userUc.NewUserUseCase(userRepository)

        emailHandler := &amp;emailHand.EmailHandler{
                EmailUseCase: emailUseCase,
                Sessions:     sessionsManager,
        }

        userHandler := &amp;userHand.UserHandler{
                UserUseCase: userUseCase,
                Sessions:    sessionsManager,
        }

        router := mux.NewRouter()
        router.HandleFunc("/api/v1/emails", emailHandler.List).Methods("GET", "OPTIONS")
        router.HandleFunc("/api/v1/email/{id}", emailHandler.GetByID).Methods("GET", "OPTIONS")
        router.HandleFunc("/api/v1/email/add", emailHandler.Add).Methods("POST", "OPTIONS")
        router.HandleFunc("/api/v1/email/update/{id}", emailHandler.Update).Methods("PUT", "OPTIONS")
        router.HandleFunc("/api/v1/email/delete/{id}", emailHandler.Delete).Methods("DELETE", "OPTIONS")

        router.HandleFunc("/api/v1/verify-auth", userHandler.VerifyAuth).Methods("GET", "OPTIONS")
        router.HandleFunc("/api/v1/login", userHandler.Login).Methods("POST", "OPTIONS")
        router.HandleFunc("/api/v1/signup", userHandler.Signup).Methods("POST", "OPTIONS")
        router.HandleFunc("/api/v1/logout", userHandler.Logout).Methods("POST", "OPTIONS")
        router.HandleFunc("/api/v1/get-user", userHandler.GetUserBySession).Methods("GET", "OPTIONS")

        router.PathPrefix("/swagger/").Handler(httpSwagger.WrapHandler)

        c := cors.New(cors.Options{
                AllowedOrigins:   []string{"http://127.0.0.1:8081", "http://89.208.223.140:8081", "http://localhost:8080", "http://localhost:8081", "http://89.208.223.140:8080"},
                AllowedMethods:   []string{http.MethodGet, http.MethodPost, http.MethodDelete, http.MethodPut, http.MethodOptions},
                AllowCredentials: true,
        })

        corsHandler := c.Handler(router)

        port := 8080
        fmt.Printf("The server is running on http://localhost:%d\n", port)
        fmt.Printf("Swagger is running on http://localhost:%d/swagger/index.html\n", port)

        err := http.ListenAndServe(fmt.Sprintf("0.0.0.0:%d", port), corsHandler)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error when starting the server:", err)
        }</span>
        // 89.208.223.140
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/api/v1/email/add": {
            "post": {
                "description": "Add a new email message to the system",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "summary": "Add a new email message",
                "parameters": [
                    {
                        "description": "Email message in JSON format",
                        "name": "email",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/delivery.Email"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "ID of the added email message",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    },
                    "400": {
                        "description": "Bad JSON in request",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    },
                    "401": {
                        "description": "Not Authorized",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    },
                    "500": {
                        "description": "Failed to add email message",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    }
                }
            }
        },
        "/api/v1/email/delete/{id}": {
            "delete": {
                "description": "Delete an email message based on its identifier",
                "produces": [
                    "application/json"
                ],
                "summary": "Delete an email message",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "ID of the email message",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Deletion success status",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    },
                    "400": {
                        "description": "Bad id",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    },
                    "401": {
                        "description": "Not Authorized",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    },
                    "500": {
                        "description": "Failed to delete email message",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    }
                }
            }
        },
        "/api/v1/email/update/{id}": {
            "put": {
                "description": "Update an existing email message based on its identifier",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "summary": "Update an email message",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "ID of the email message",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Email message in JSON format",
                        "name": "email",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/delivery.Email"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Update success status",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    },
                    "400": {
                        "description": "Bad id or Bad JSON",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    },
                    "401": {
                        "description": "Not Authorized",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    },
                    "500": {
                        "description": "Failed to update email message",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    }
                }
            }
        },
        "/api/v1/email/{id}": {
            "get": {
                "description": "Get an email message by its unique identifier",
                "produces": [
                    "application/json"
                ],
                "summary": "Get an email message by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "ID of the email message",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Email message data",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    },
                    "400": {
                        "description": "Bad id in request",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    },
                    "401": {
                        "description": "Not Authorized",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    },
                    "404": {
                        "description": "Email not found",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    }
                }
            }
        },
        "/api/v1/emails": {
            "get": {
                "description": "Get a list of all email messages",
                "produces": [
                    "application/json"
                ],
                "summary": "Display the list of email messages",
                "responses": {
                    "200": {
                        "description": "List of all email messages",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    },
                    "401": {
                        "description": "Not Authorized",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    },
                    "404": {
                        "description": "DB error",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    },
                    "500": {
                        "description": "JSON encoding error",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    }
                }
            }
        },
        "/api/v1/get-user": {
            "get": {
                "description": "Retrieve the user associated with the current session",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Get user by session",
                "responses": {
                    "200": {
                        "description": "User details",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    },
                    "401": {
                        "description": "Not Authorized",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/delivery.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/login": {
            "post": {
                "description": "Handles user login.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "User login",
                "parameters": [
                    {
                        "description": "User credentials for login",
                        "name": "credentials",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/delivery.User"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Login successful",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    },
                    "400": {
                        "description": "Invalid request body",
                        "schema": {
                            "$ref": "#/definitions/delivery.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Invalid credentials",
                        "schema": {
                            "$ref": "#/definitions/delivery.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to create session",
                        "schema": {
                            "$ref": "#/definitions/delivery.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/logout": {
            "post": {
                "description": "Handles user logout.",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "User logout",
                "responses": {
                    "200": {
                        "description": "Logout successful",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    }
                }
            }
        },
        "/api/v1/signup": {
            "post": {
                "description": "Handles user signup.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "User signup",
                "parameters": [
                    {
                        "description": "New user details for signup",
                        "name": "newUser",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/delivery.User"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Signup successful",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    },
                    "400": {
                        "description": "Invalid request body",
                        "schema": {
                            "$ref": "#/definitions/delivery.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to add user",
                        "schema": {
                            "$ref": "#/definitions/delivery.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/verify-auth": {
            "get": {
                "description": "Verify user authentication using sessions",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Verify user authentication",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    },
                    "401": {
                        "description": "Not Authorized",
                        "schema": {
                            "$ref": "#/definitions/delivery.Response"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "delivery.Email": {
            "type": "object"
        },
        "delivery.ErrorResponse": {
            "type": "object",
            "properties": {
                "error": {
                    "type": "string"
                }
            }
        },
        "delivery.Response": {
            "type": "object",
            "properties": {
                "body": {},
                "status": {
                    "type": "integer"
                }
            }
        },
        "delivery.User": {
            "type": "object"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/",
        Schemes:          []string{},
        Title:            "API Mail",
        Description:      "API server for mail",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package converters

import (
        emailApi "mail/pkg/delivery/models"
        emailCore "mail/pkg/domain/models"
)

func EmailConvertCoreInApi(emailModelDb emailCore.Email) *emailApi.Email <span class="cov8" title="1">{
        return &amp;emailApi.Email{
                ID:             emailModelDb.ID,
                Topic:          emailModelDb.Topic,
                Text:           emailModelDb.Text,
                PhotoID:        emailModelDb.PhotoID,
                ReadStatus:     emailModelDb.ReadStatus,
                Mark:           emailModelDb.Mark,
                Deleted:        emailModelDb.Deleted,
                DateOfDispatch: emailModelDb.DateOfDispatch,
                ReplyToEmailID: emailModelDb.ReplyToEmailID,
                DraftStatus:    emailModelDb.DraftStatus,
        }
}</span>

func EmailConvertApiInCore(emailModelCore emailApi.Email) *emailCore.Email <span class="cov8" title="1">{
        return &amp;emailCore.Email{
                ID:             emailModelCore.ID,
                Topic:          emailModelCore.Topic,
                Text:           emailModelCore.Text,
                PhotoID:        emailModelCore.PhotoID,
                ReadStatus:     emailModelCore.ReadStatus,
                Mark:           emailModelCore.Mark,
                Deleted:        emailModelCore.Deleted,
                DateOfDispatch: emailModelCore.DateOfDispatch,
                ReplyToEmailID: emailModelCore.ReplyToEmailID,
                DraftStatus:    emailModelCore.DraftStatus,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package converters

import (
        userApi "mail/pkg/delivery/models"
        userCore "mail/pkg/domain/models"
)

func UserConvertCoreInApi(userModelCore userCore.User) *userApi.User <span class="cov0" title="0">{
        return &amp;userApi.User{
                ID:       userModelCore.ID,
                Login:    userModelCore.Login,
                Name:     userModelCore.Name,
                Surname:  userModelCore.Surname,
                AvatarID: userModelCore.AvatarID,
        }
}</span>

func UserConvertApiInCore(userModelApi userApi.User) *userCore.User <span class="cov8" title="1">{
        return &amp;userCore.User{
                ID:       userModelApi.ID,
                Login:    userModelApi.Login,
                Password: userModelApi.Password,
                Name:     userModelApi.Name,
                Surname:  userModelApi.Surname,
                AvatarID: userModelApi.AvatarID,
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package email

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"

        "mail/pkg/delivery"
        "mail/pkg/delivery/converters"

        emailApi "mail/pkg/delivery/models"
        "mail/pkg/delivery/session"
        emailUsecase "mail/pkg/domain/usecase"

        "github.com/gorilla/mux"
        "github.com/gorilla/schema"
)

// EmailHandler represents the handler for email operations.
type EmailHandler struct {
        EmailUseCase emailUsecase.EmailUseCase
        Sessions     *session.SessionsManager
}

// List displays the list of email messages.
// @Summary Display the list of email messages
// @Description Get a list of all email messages
// @Produce json
// @Success 200 {object} delivery.Response "List of all email messages"
// @Failure 401 {object} delivery.Response "Not Authorized"
// @Failure 404 {object} delivery.Response "DB error"
// @Failure 500 {object} delivery.Response "JSON encoding error"
// @Router /api/v1/emails [get]
func (h *EmailHandler) List(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        _, err := h.Sessions.Check(r)
        if err != nil </span><span class="cov8" title="1">{
                delivery.HandleError(w, http.StatusUnauthorized, "Not Authorized")
                return
        }</span>

        <span class="cov8" title="1">emails, err := h.EmailUseCase.GetAllEmails()
        if err != nil </span><span class="cov0" title="0">{
                delivery.HandleError(w, http.StatusNotFound, fmt.Sprintf("DB error: %s", err.Error()))
                return
        }</span>

        <span class="cov8" title="1">emailsApi := make([]*emailApi.Email, 0, len(emails))
        for _, email := range emails </span><span class="cov8" title="1">{
                emailsApi = append(emailsApi, converters.EmailConvertCoreInApi(*email))
        }</span>

        <span class="cov8" title="1">delivery.HandleSuccess(w, http.StatusOK, map[string]interface{}{"emails": emailsApi})</span>
}

// GetByID returns an email message by its ID.
// @Summary Get an email message by ID
// @Description Get an email message by its unique identifier
// @Produce json
// @Param id path integer true "ID of the email message"
// @Success 200 {object} delivery.Response "Email message data"
// @Failure 400 {object} delivery.Response "Bad id in request"
// @Failure 401 {object} delivery.Response "Not Authorized"
// @Failure 404 {object} delivery.Response "Email not found"
// @Router /api/v1/email/{id} [get]
func (h *EmailHandler) GetByID(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        _, err := h.Sessions.Check(r)
        if err != nil </span><span class="cov8" title="1">{
                delivery.HandleError(w, http.StatusUnauthorized, "Not Authorized")
                return
        }</span>

        <span class="cov8" title="1">vars := mux.Vars(r)
        id, err := strconv.ParseUint(vars["id"], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                delivery.HandleError(w, http.StatusBadRequest, "Bad id in request")
                return
        }</span>

        <span class="cov8" title="1">email, err := h.EmailUseCase.GetEmailByID(id)
        if err != nil </span><span class="cov8" title="1">{
                delivery.HandleError(w, http.StatusNotFound, "Email not found")
                return
        }</span>

        <span class="cov8" title="1">delivery.HandleSuccess(w, http.StatusOK, map[string]interface{}{"email": converters.EmailConvertCoreInApi(*email)})</span>
}

// Add adds a new email message.
// @Summary Add a new email message
// @Description Add a new email message to the system
// @Accept json
// @Produce json
// @Param email body delivery.Email true "Email message in JSON format"
// @Success 200 {object} delivery.Response "ID of the added email message"
// @Failure 400 {object} delivery.Response "Bad JSON in request"
// @Failure 401 {object} delivery.Response "Not Authorized"
// @Failure 500 {object} delivery.Response "Failed to add email message"
// @Router /api/v1/email/add [post]
func (h *EmailHandler) Add(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        _, err := h.Sessions.Check(r)
        if err != nil </span><span class="cov8" title="1">{
                delivery.HandleError(w, http.StatusUnauthorized, "Not Authorized")
                return
        }</span>

        <span class="cov8" title="1">var newEmail emailApi.Email
        decoder := schema.NewDecoder()
        decoder.IgnoreUnknownKeys(true)
        err = json.NewDecoder(r.Body).Decode(&amp;newEmail)
        if err != nil </span><span class="cov8" title="1">{
                delivery.HandleError(w, http.StatusBadRequest, "Bad JSON in request")
                return
        }</span>

        <span class="cov8" title="1">email, err := h.EmailUseCase.CreateEmail(converters.EmailConvertApiInCore(newEmail))
        if err != nil </span><span class="cov0" title="0">{
                delivery.HandleError(w, http.StatusInternalServerError, "Failed to add email message")
                return
        }</span>

        <span class="cov8" title="1">delivery.HandleSuccess(w, http.StatusOK, map[string]interface{}{"email": converters.EmailConvertCoreInApi(*email)})</span>
}

// Update updates an existing email message.
// @Summary Update an email message
// @Description Update an existing email message based on its identifier
// @Accept json
// @Produce json
// @Param id path integer true "ID of the email message"
// @Param email body delivery.Email true "Email message in JSON format"
// @Success 200 {object} delivery.Response "Update success status"
// @Failure 400 {object} delivery.Response "Bad id or Bad JSON"
// @Failure 401 {object} delivery.Response "Not Authorized"
// @Failure 500 {object} delivery.Response "Failed to update email message"
// @Router /api/v1/email/update/{id} [put]
func (h *EmailHandler) Update(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        _, err := h.Sessions.Check(r)
        if err != nil </span><span class="cov8" title="1">{
                delivery.HandleError(w, http.StatusUnauthorized, "Not Authorized")
                return
        }</span>

        <span class="cov8" title="1">vars := mux.Vars(r)
        id, err := strconv.ParseUint(vars["id"], 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                delivery.HandleError(w, http.StatusBadRequest, "Bad id in request")
                return
        }</span>

        <span class="cov8" title="1">var updatedEmail emailApi.Email
        decoder := schema.NewDecoder()
        decoder.IgnoreUnknownKeys(true)
        err = json.NewDecoder(r.Body).Decode(&amp;updatedEmail)
        if err != nil </span><span class="cov8" title="1">{
                delivery.HandleError(w, http.StatusBadRequest, "Bad JSON in request")
                return
        }</span>
        <span class="cov0" title="0">updatedEmail.ID = id

        ok, err := h.EmailUseCase.UpdateEmail(converters.EmailConvertApiInCore(updatedEmail))
        if err != nil </span><span class="cov0" title="0">{
                delivery.HandleError(w, http.StatusInternalServerError, "Failed to update email message")
                return
        }</span>

        <span class="cov0" title="0">delivery.HandleSuccess(w, http.StatusOK, map[string]interface{}{"Success": ok})</span>
}

// Delete deletes an email message.
// @Summary Delete an email message
// @Description Delete an email message based on its identifier
// @Produce json
// @Param id path integer true "ID of the email message"
// @Success 200 {object} delivery.Response "Deletion success status"
// @Failure 400 {object} delivery.Response "Bad id"
// @Failure 401 {object} delivery.Response "Not Authorized"
// @Failure 500 {object} delivery.Response "Failed to delete email message"
// @Router /api/v1/email/delete/{id} [delete]
func (h *EmailHandler) Delete(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        _, err := h.Sessions.Check(r)
        if err != nil </span><span class="cov8" title="1">{
                delivery.HandleError(w, http.StatusUnauthorized, "Not Authorized")
                return
        }</span>

        <span class="cov8" title="1">vars := mux.Vars(r)
        id, err := strconv.ParseUint(vars["id"], 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                delivery.HandleError(w, http.StatusBadRequest, "Bad id in request")
                return
        }</span>

        <span class="cov8" title="1">ok, err := h.EmailUseCase.DeleteEmail(id)
        if err != nil </span><span class="cov0" title="0">{
                delivery.HandleError(w, http.StatusInternalServerError, "Failed to delete email message")
                return
        }</span>

        <span class="cov8" title="1">delivery.HandleSuccess(w, http.StatusOK, map[string]interface{}{"Success": ok})</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package middleware

import (
        "net/http"
)

// AuthMiddleware is a middleware to check user authentication using cookies.
func AuthMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                cookie, err := r.Cookie("session_id")

                if err != nil || cookie.Value == "" </span><span class="cov8" title="1">{
                        w.Header().Set("Location", "/login")
                        w.WriteHeader(http.StatusFound)
                        return
                }</span>

                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package delivery

import (
        "encoding/json"
        "net/http"

        api "mail/pkg/delivery/models"
)

// Response represents the response format.
type Response struct {
        Status int         `json:"status"`
        Body   interface{} `json:"body"`
}

// ErrorResponse represents the error response format.
type ErrorResponse struct {
        Error string `json:"error"`
}

// HandleSuccess is a utility function to handle successful responses uniformly in the API.
func HandleSuccess(w http.ResponseWriter, status int, body interface{}) <span class="cov8" title="1">{
        response := Response{
                Status: status,
                Body:   body,
        }
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        json.NewEncoder(w).Encode(response)
}</span>

// HandleError is a utility function to handle errors uniformly in the API responses.
func HandleError(w http.ResponseWriter, status int, message string) <span class="cov8" title="1">{
        response := Response{
                Status: status,
                Body:   ErrorResponse{Error: message},
        }
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        json.NewEncoder(w).Encode(response)
}</span>

type Email = api.Email
type User = api.User
</pre>
		
		<pre class="file" id="file7" style="display: none">package session

import (
        "net/http"
        "sync"
        "time"
)

type SessionsManager struct {
        mu   *sync.RWMutex
        data map[string]*Session
}

func NewSessionsManager() *SessionsManager <span class="cov8" title="1">{
        return &amp;SessionsManager{
                data: make(map[string]*Session, 10),
                mu:   &amp;sync.RWMutex{},
        }
}</span>

func (sm *SessionsManager) Check(r *http.Request) (*Session, error) <span class="cov8" title="1">{
        sessionCookie, err := r.Cookie("session_id")
        if err == http.ErrNoCookie </span><span class="cov8" title="1">{
                return nil, ErrNoAuth
        }</span>

        <span class="cov8" title="1">sm.mu.RLock()
        sess, ok := sm.data[sessionCookie.Value]
        sm.mu.RUnlock()

        if !ok </span><span class="cov0" title="0">{
                return nil, ErrNoAuth
        }</span>

        <span class="cov8" title="1">return sess, nil</span>
}

func (sm *SessionsManager) Create(w http.ResponseWriter, userID uint32) (*Session, error) <span class="cov8" title="1">{
        sess := NewSession(userID)

        sm.mu.RLock()
        sm.data[sess.ID] = sess
        sm.mu.RUnlock()

        cookie := &amp;http.Cookie{
                Name:    "session_id",
                Value:   sess.ID,
                Expires: time.Now().Add(90 * 24 * time.Hour),
                Path:    "/",
        }
        http.SetCookie(w, cookie)

        return sess, nil
}</span>

func (sm *SessionsManager) DestroyCurrent(w http.ResponseWriter, r *http.Request) error <span class="cov8" title="1">{
        c, err := r.Cookie("session_id")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">sm.mu.RLock()
        delete(sm.data, c.Value)
        sm.mu.RUnlock()

        cookie := http.Cookie{
                Name:    "session_id",
                Expires: time.Now().AddDate(0, 0, -1),
                Path:    "/",
        }
        http.SetCookie(w, &amp;cookie)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package session

import (
        "context"
        "crypto/rand"
        "errors"
        "fmt"
)

type Session struct {
        ID     string
        UserID uint32
}

func NewSession(userID uint32) *Session <span class="cov8" title="1">{
        randID := make([]byte, 16)
        rand.Read(randID)

        return &amp;Session{
                ID:     fmt.Sprintf("%x", randID),
                UserID: userID,
        }
}</span>

var (
        ErrNoAuth = errors.New("No session found")
)

type sessionKey string

var SessionKey sessionKey = "sessionKey"

func SessionFromContext(ctx context.Context) (*Session, error) <span class="cov8" title="1">{
        sess, ok := ctx.Value(SessionKey).(*Session)
        if !ok || sess == nil </span><span class="cov8" title="1">{
                return nil, ErrNoAuth
        }</span>

        <span class="cov8" title="1">return sess, nil</span>
}

func ContextWithSession(ctx context.Context, sess *Session) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, SessionKey, sess)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package user

import (
        "encoding/json"
        "mail/pkg/delivery"
        "mail/pkg/delivery/converters"
        "mail/pkg/delivery/models"
        "mail/pkg/delivery/session"
        "mail/pkg/domain/usecase"
        "net/http"
        "strings"
)

// UserHandler handles user-related HTTP requests.
type UserHandler struct {
        UserUseCase usecase.UserUseCase
        Sessions    *session.SessionsManager
}

// VerifyAuth verifies user authentication.
// @Summary Verify user authentication
// @Description Verify user authentication using sessions
// @Tags users
// @Produce json
// @Success 200 {object} delivery.Response "OK"
// @Failure 401 {object} delivery.Response "Not Authorized"
// @Router /api/v1/verify-auth [get]
func (uh *UserHandler) VerifyAuth(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        _, err := uh.Sessions.Check(r)
        if err != nil </span><span class="cov0" title="0">{
                delivery.HandleError(w, http.StatusUnauthorized, "Not Authorized")
                return
        }</span>

        <span class="cov0" title="0">delivery.HandleSuccess(w, http.StatusOK, map[string]interface{}{"Success": "OK"})</span>
}

// Login handles user login.
// @Summary User login
// @Description Handles user login.
// @Tags users
// @Accept json
// @Produce json
// @Param credentials body delivery.User true "User credentials for login"
// @Success 200 {object} delivery.Response "Login successful"
// @Failure 400 {object} delivery.ErrorResponse "Invalid request body"
// @Failure 401 {object} delivery.ErrorResponse "Invalid credentials"
// @Failure 500 {object} delivery.ErrorResponse "Failed to create session"
// @Router /api/v1/login [post]
func (uh *UserHandler) Login(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var credentials models.User
        err := json.NewDecoder(r.Body).Decode(&amp;credentials)
        if err != nil </span><span class="cov8" title="1">{
                delivery.HandleError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov8" title="1">if isEmpty(credentials.Login) || isEmpty(credentials.Password) </span><span class="cov0" title="0">{
                delivery.HandleError(w, http.StatusInternalServerError, "All fields must be filled in")
                return
        }</span>

        <span class="cov8" title="1">ourUser, err := uh.UserUseCase.GetUserByLogin(credentials.Login, credentials.Password)
        if err != nil </span><span class="cov8" title="1">{
                delivery.HandleError(w, http.StatusUnauthorized, "Login failed")
                return
        }</span>

        <span class="cov8" title="1">_, er := uh.Sessions.Create(w, ourUser.ID)
        if er != nil </span><span class="cov0" title="0">{
                delivery.HandleError(w, http.StatusInternalServerError, "Failed to create session")
                return
        }</span>

        <span class="cov8" title="1">delivery.HandleSuccess(w, http.StatusOK, map[string]interface{}{"Success": "Login successful"})</span>
}

// Signup handles user signup.
// @Summary User signup
// @Description Handles user signup.
// @Tags users
// @Accept json
// @Produce json
// @Param newUser body delivery.User true "New user details for signup"
// @Success 200 {object} delivery.Response "Signup successful"
// @Failure 400 {object} delivery.ErrorResponse "Invalid request body"
// @Failure 500 {object} delivery.ErrorResponse "Failed to add user"
// @Router /api/v1/signup [post]
func (uh *UserHandler) Signup(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var newUser models.User
        err := json.NewDecoder(r.Body).Decode(&amp;newUser)
        if err != nil </span><span class="cov8" title="1">{
                delivery.HandleError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov8" title="1">if isEmpty(newUser.Name) || isEmpty(newUser.Surname) || isEmpty(newUser.Login) || isEmpty(newUser.Password) </span><span class="cov8" title="1">{
                delivery.HandleError(w, http.StatusBadRequest, "All fields must be filled in")
        }</span>

        <span class="cov8" title="1">users, _ := uh.UserUseCase.GetAllUsers()
        for _, u := range users </span><span class="cov8" title="1">{
                if u.Login == newUser.Login </span><span class="cov0" title="0">{
                        delivery.HandleError(w, http.StatusBadRequest, "Such a login already exists")
                        return
                }</span>
        }

        <span class="cov8" title="1">_, er := uh.UserUseCase.CreateUser(converters.UserConvertApiInCore(newUser))
        if er != nil </span><span class="cov0" title="0">{
                delivery.HandleError(w, http.StatusInternalServerError, "Failed to add user")
        }</span>

        <span class="cov8" title="1">delivery.HandleSuccess(w, http.StatusOK, map[string]interface{}{"Success": "Signup successful"})</span>
}

// Logout handles user logout.
// @Summary User logout
// @Description Handles user logout.
// @Tags users
// @Produce json
// @Success 200 {object} delivery.Response "Logout successful"
// @Router /api/v1/logout [post]
func (uh *UserHandler) Logout(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        err := uh.Sessions.DestroyCurrent(w, r)
        if err != nil </span><span class="cov0" title="0">{
                delivery.HandleError(w, http.StatusUnauthorized, "Not Authorized")
                return
        }</span>

        <span class="cov8" title="1">delivery.HandleSuccess(w, http.StatusOK, map[string]interface{}{"Success": "Logout successful"})</span>
}

// GetUserBySession retrieves the user associated with the current session.
// @Summary Get user by session
// @Description Retrieve the user associated with the current session
// @Tags users
// @Produce json
// @Success 200 {object} delivery.Response "User details"
// @Failure 401 {object} delivery.Response "Not Authorized"
// @Failure 500 {object} delivery.ErrorResponse "Internal Server Error"
// @Router /api/v1/get-user [get]
func (uh *UserHandler) GetUserBySession(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionUser, err := uh.Sessions.Check(r)
        if err != nil </span><span class="cov0" title="0">{
                delivery.HandleError(w, http.StatusUnauthorized, "Not Authorized")
                return
        }</span>

        <span class="cov0" title="0">userData, err := uh.UserUseCase.GetUserByID(sessionUser.UserID)
        if err != nil </span><span class="cov0" title="0">{
                delivery.HandleError(w, http.StatusInternalServerError, "Internal Server Error")
                return
        }</span>

        <span class="cov0" title="0">delivery.HandleSuccess(w, http.StatusOK, map[string]interface{}{"user": converters.UserConvertCoreInApi(*userData)})</span>
}

// isEmpty checks if the given string is empty after trimming leading and trailing whitespace.
// Returns true if the string is empty, and false otherwise.
func isEmpty(str string) bool <span class="cov8" title="1">{
        return strings.TrimSpace(str) == ""
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package converters

import (
        emailCore "mail/pkg/domain/models"
        emailDb "mail/pkg/repository/models"
)

func EmailConvertDbInCore(emailModelDb emailDb.Email) *emailCore.Email <span class="cov8" title="1">{
        return &amp;emailCore.Email{
                ID:             emailModelDb.ID,
                Topic:          emailModelDb.Topic,
                Text:           emailModelDb.Text,
                PhotoID:        emailModelDb.PhotoID,
                ReadStatus:     emailModelDb.ReadStatus,
                Mark:           emailModelDb.Mark,
                Deleted:        emailModelDb.Deleted,
                DateOfDispatch: emailModelDb.DateOfDispatch,
                ReplyToEmailID: emailModelDb.ReplyToEmailID,
                DraftStatus:    emailModelDb.DraftStatus,
        }
}</span>

func EmailConvertCoreInDb(emailModelCore emailCore.Email) *emailDb.Email <span class="cov8" title="1">{
        return &amp;emailDb.Email{
                ID:             emailModelCore.ID,
                Topic:          emailModelCore.Topic,
                Text:           emailModelCore.Text,
                PhotoID:        emailModelCore.PhotoID,
                ReadStatus:     emailModelCore.ReadStatus,
                Mark:           emailModelCore.Mark,
                Deleted:        emailModelCore.Deleted,
                DateOfDispatch: emailModelCore.DateOfDispatch,
                ReplyToEmailID: emailModelCore.ReplyToEmailID,
                DraftStatus:    emailModelCore.DraftStatus,
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package converters

import (
        userCore "mail/pkg/domain/models"
        userDb "mail/pkg/repository/models"
)

func UserConvertDbInCore(userModelDb userDb.User) *userCore.User <span class="cov8" title="1">{
        return &amp;userCore.User{
                ID:       userModelDb.ID,
                Login:    userModelDb.Login,
                Password: userModelDb.Password,
                Name:     userModelDb.Name,
                Surname:  userModelDb.Surname,
                AvatarID: userModelDb.AvatarID,
        }
}</span>

func UserConvertCoreInDb(userModelCore userCore.User) *userDb.User <span class="cov8" title="1">{
        return &amp;userDb.User{
                ID:       userModelCore.ID,
                Login:    userModelCore.Login,
                Password: userModelCore.Password,
                Name:     userModelCore.Name,
                Surname:  userModelCore.Surname,
                AvatarID: userModelCore.AvatarID,
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package email

import (
        "fmt"
        "mail/pkg/repository/converters"
        "sync"

        emailCore "mail/pkg/domain/models"
        "mail/pkg/repository/models"
)

// EmailMemoryRepository represents the implementation of EmailRepository using an in-memory storage.
type EmailMemoryRepository struct {
        mu     sync.RWMutex
        emails map[uint64]*models.Email
}

// NewEmailMemoryRepository creates a new instance of EmailMemoryRepository.
func NewEmailMemoryRepository() *EmailMemoryRepository <span class="cov0" title="0">{
        fakeEmails := FakeEmails

        return &amp;EmailMemoryRepository{
                emails: fakeEmails,
        }
}</span>

// NewEmptyInMemoryEmailRepository creates a new email repository in memory with an empty default email list.
func NewEmptyInMemoryEmailRepository() *EmailMemoryRepository <span class="cov8" title="1">{
        defaultEmails := map[uint64]*models.Email{}

        return &amp;EmailMemoryRepository{
                emails: defaultEmails,
        }
}</span>

func CreateFakeEmails() *EmailMemoryRepository <span class="cov8" title="1">{
        repo := NewEmptyInMemoryEmailRepository()

        for i := 1; i-1 &lt; len(FakeEmails); i++ </span><span class="cov8" title="1">{
                repo.emails[uint64(i)] = FakeEmails[uint64(i)]
        }</span>

        <span class="cov8" title="1">return repo</span>
}

// GetAll returns all emails from the storage.
func (repository *EmailMemoryRepository) GetAll() ([]*emailCore.Email, error) <span class="cov8" title="1">{
        repository.mu.RLock()
        defer repository.mu.RUnlock()

        emails := make([]*emailCore.Email, 0, len(repository.emails))
        for _, email := range repository.emails </span><span class="cov8" title="1">{
                emails = append(emails, converters.EmailConvertDbInCore(*email))
        }</span>

        <span class="cov8" title="1">return emails, nil</span>
}

// GetByID returns an email based on its unique identifier.
func (repository *EmailMemoryRepository) GetByID(id uint64) (*emailCore.Email, error) <span class="cov8" title="1">{
        repository.mu.RLock()
        defer repository.mu.RUnlock()

        email, found := repository.emails[id]
        if !found </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Email with id %d not found", id)
        }</span>

        <span class="cov8" title="1">return converters.EmailConvertDbInCore(*email), nil</span>
}

// Add adds a new email to the storage and returns the assigned unique identifier.
func (repository *EmailMemoryRepository) Add(email *emailCore.Email) (*emailCore.Email, error) <span class="cov8" title="1">{
        repository.mu.Lock()
        defer repository.mu.Unlock()

        emailDb := converters.EmailConvertCoreInDb(*email)

        id := uint64(len(repository.emails) + 1)
        emailDb.ID = id
        repository.emails[id] = emailDb

        return converters.EmailConvertDbInCore(*repository.emails[id]), nil
}</span>

// Update updates the data of an email in the storage based on the provided new email.
func (repository *EmailMemoryRepository) Update(newEmail *emailCore.Email) (bool, error) <span class="cov8" title="1">{
        repository.mu.Lock()
        defer repository.mu.Unlock()

        emailDb := converters.EmailConvertCoreInDb(*newEmail)

        existingEmail, found := repository.emails[emailDb.ID]
        if !found </span><span class="cov0" title="0">{
                return false, fmt.Errorf("Email with id %d not found", emailDb.ID)
        }</span>

        <span class="cov8" title="1">existingEmail.Topic = emailDb.Topic
        existingEmail.Text = emailDb.Text
        existingEmail.PhotoID = emailDb.PhotoID
        existingEmail.ReadStatus = emailDb.ReadStatus
        existingEmail.Mark = emailDb.Mark
        existingEmail.Deleted = emailDb.Deleted
        existingEmail.DateOfDispatch = emailDb.DateOfDispatch
        existingEmail.ReplyToEmailID = emailDb.ReplyToEmailID
        existingEmail.DraftStatus = emailDb.DraftStatus

        return true, nil</span>
}

// Delete removes an email from the storage based on its unique identifier.
func (repository *EmailMemoryRepository) Delete(id uint64) (bool, error) <span class="cov8" title="1">{
        repository.mu.Lock()
        defer repository.mu.Unlock()

        _, found := repository.emails[id]
        if !found </span><span class="cov0" title="0">{
                return false, fmt.Errorf("Email with id %d not found", id)
        }</span>

        <span class="cov8" title="1">delete(repository.emails, id)

        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package user

import (
        "fmt"
        "golang.org/x/crypto/bcrypt"
        userCore "mail/pkg/domain/models"
        "mail/pkg/repository/converters"
        "mail/pkg/repository/models"
        "sync"
)

// UserMemoryRepository is an in-memory implementation of UserRepository.
type UserMemoryRepository struct {
        mutex sync.RWMutex
        users map[uint32]*models.User
}

// NewUserMemoryRepository creates a new instance of UserMemoryRepository.
func NewInMemoryUserRepository() *UserMemoryRepository <span class="cov8" title="1">{
        return &amp;UserMemoryRepository{
                users: FakeUsers,
        }
}</span>

// NewEmptyInMemoryUserRepository creates a new user repository in memory with an empty default user list.
func NewEmptyInMemoryUserRepository() *UserMemoryRepository <span class="cov8" title="1">{
        defaultUsers := map[uint32]*models.User{}
        return &amp;UserMemoryRepository{
                users: defaultUsers,
        }
}</span>

// HashPassword takes a plaintext password as input and returns its bcrypt hash.
func HashPassword(password string) (string, bool) <span class="cov8" title="1">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov8" title="1">hashedPassword := string(bytes)
        fmt.Println("Hashed Password:", hashedPassword)

        return string(bytes), true</span>
}

// CheckPasswordHash compares a password with a hash and returns true if they match, otherwise false.
func CheckPasswordHash(password, hash string) bool <span class="cov8" title="1">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>

// ComparingUserObjects compares two user objects by comparing their IDs, names, surnames, logins, and password hashes.
// If all fields match, the function returns true, otherwise false.
func ComparingUserObjects(object1, object2 userCore.User) bool <span class="cov0" title="0">{
        userDb1 := converters.UserConvertCoreInDb(object1)
        userDb2 := converters.UserConvertCoreInDb(object2)

        if userDb1.ID == userDb2.ID &amp;&amp;
                userDb1.Name == userDb2.Name &amp;&amp;
                userDb1.Surname == userDb2.Surname &amp;&amp;
                userDb1.Login == userDb2.Login &amp;&amp;
                CheckPasswordHash(userDb2.Password, userDb1.Password) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// GetAll returns all users from the storage.
func (repo *UserMemoryRepository) GetAll() ([]*userCore.User, error) <span class="cov8" title="1">{
        repo.mutex.RLock()
        defer repo.mutex.RUnlock()

        users := make([]*userCore.User, 0, len(repo.users))
        for i := 0; i &lt; len(repo.users); i++ </span><span class="cov8" title="1">{
                users = append(users, converters.UserConvertDbInCore(*repo.users[uint32(i+1)]))
        }</span>

        <span class="cov8" title="1">return users, nil</span>
}

// GetByID returns the user by its unique identifier.
func (repo *UserMemoryRepository) GetByID(id uint32) (*userCore.User, error) <span class="cov8" title="1">{
        repo.mutex.RLock()
        defer repo.mutex.RUnlock()

        user, exists := repo.users[id]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("User with id %d not found", id)
        }</span>

        <span class="cov8" title="1">return converters.UserConvertDbInCore(*user), nil</span>
}

// GetUserByLogin returns the user by login.
func (repo *UserMemoryRepository) GetUserByLogin(login string, password string) (*userCore.User, error) <span class="cov8" title="1">{
        repo.mutex.RLock()
        defer repo.mutex.RUnlock()

        for _, u := range repo.users </span><span class="cov8" title="1">{
                if u.Login == login </span><span class="cov8" title="1">{
                        if CheckPasswordHash(password, u.Password) </span><span class="cov8" title="1">{
                                return converters.UserConvertDbInCore(*u), nil
                        }</span> else<span class="cov8" title="1"> {
                                return nil, fmt.Errorf("User with the username %s was not found", login)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("User with the username %s was not found", login)</span>
}

// Add adds a new user to the storage and returns its assigned unique identifier.
func (repo *UserMemoryRepository) Add(user *userCore.User) (uint32, error) <span class="cov8" title="1">{
        repo.mutex.Lock()
        defer repo.mutex.Unlock()

        userDb := converters.UserConvertCoreInDb(*user)

        userID := uint32(len(repo.users) + 1)
        userDb.ID = userID
        var err bool
        userDb.Password, err = HashPassword(userDb.Password)
        if err == false </span><span class="cov0" title="0">{
                return userID, fmt.Errorf("Operation failed")
        }</span>
        <span class="cov8" title="1">repo.users[userID] = userDb

        return userID, nil</span>
}

// Update updates the information of a user in the storage based on the provided new user.
func (repo *UserMemoryRepository) Update(newUser *userCore.User) (bool, error) <span class="cov8" title="1">{
        repo.mutex.Lock()
        defer repo.mutex.Unlock()

        newUserDb := converters.UserConvertCoreInDb(*newUser)

        _, exists := repo.users[newUserDb.ID]
        if !exists </span><span class="cov0" title="0">{
                return false, fmt.Errorf("User with id %d not found", newUserDb.ID)
        }</span>

        <span class="cov8" title="1">repo.users[newUserDb.ID] = newUserDb

        return true, nil</span>
}

// Delete removes the user from the storage by its unique identifier.
func (repo *UserMemoryRepository) Delete(id uint32) (bool, error) <span class="cov8" title="1">{
        repo.mutex.Lock()
        defer repo.mutex.Unlock()

        _, exists := repo.users[id]
        if !exists </span><span class="cov0" title="0">{
                return false, fmt.Errorf("User with id %d not found", id)
        }</span>

        <span class="cov8" title="1">delete(repo.users, id)

        return true, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package email

import (
        emailCore "mail/pkg/domain/models"
        "mail/pkg/domain/repository"
)

// EmailUseCase represents the use case for working with emails.
type EmailUseCase struct {
        repo repository.EmailRepository
}

// NewEmailUseCase creates a new instance of EmailUseCase.
func NewEmailUseCase(repo repository.EmailRepository) *EmailUseCase <span class="cov8" title="1">{
        return &amp;EmailUseCase{
                repo: repo,
        }
}</span>

// GetAllEmails returns all emails.
func (uc *EmailUseCase) GetAllEmails() ([]*emailCore.Email, error) <span class="cov8" title="1">{
        return uc.repo.GetAll()
}</span>

// GetEmailByID returns the email by its ID.
func (uc *EmailUseCase) GetEmailByID(id uint64) (*emailCore.Email, error) <span class="cov8" title="1">{
        return uc.repo.GetByID(id)
}</span>

// CreateEmail creates a new email.
func (uc *EmailUseCase) CreateEmail(newEmail *emailCore.Email) (*emailCore.Email, error) <span class="cov8" title="1">{
        return uc.repo.Add(newEmail)
}</span>

// UpdateEmail updates the information of an email.
func (uc *EmailUseCase) UpdateEmail(updatedEmail *emailCore.Email) (bool, error) <span class="cov8" title="1">{
        return uc.repo.Update(updatedEmail)
}</span>

// DeleteEmail deletes the email.
func (uc *EmailUseCase) DeleteEmail(id uint64) (bool, error) <span class="cov8" title="1">{
        return uc.repo.Delete(id)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package user

import (
        userCore "mail/pkg/domain/models"
        "mail/pkg/domain/repository"
)

// UserUseCase represents the use case for working with users.
type UserUseCase struct {
        repo repository.UserRepository
}

// NewUserUseCase creates a new instance of UserUseCase.
func NewUserUseCase(repo repository.UserRepository) *UserUseCase <span class="cov8" title="1">{
        return &amp;UserUseCase{
                repo: repo,
        }
}</span>

// GetAllUsers returns all users.
func (uc *UserUseCase) GetAllUsers() ([]*userCore.User, error) <span class="cov8" title="1">{
        return uc.repo.GetAll()
}</span>

// GetUserByID returns the user by its ID.
func (uc *UserUseCase) GetUserByID(id uint32) (*userCore.User, error) <span class="cov8" title="1">{
        return uc.repo.GetByID(id)
}</span>

// GetUserByLogin returns the user by login.
func (uc *UserUseCase) GetUserByLogin(login string, password string) (*userCore.User, error) <span class="cov8" title="1">{
        return uc.repo.GetUserByLogin(login, password)
}</span>

// CreateUser creates a new user.
func (uc *UserUseCase) CreateUser(user *userCore.User) (uint32, error) <span class="cov8" title="1">{
        return uc.repo.Add(user)
}</span>

// UpdateUser updates the user's information.
func (uc *UserUseCase) UpdateUser(user *userCore.User) (bool, error) <span class="cov8" title="1">{
        return uc.repo.Update(user)
}</span>

// DeleteUser deletes the user.
func (uc *UserUseCase) DeleteUser(id uint32) (bool, error) <span class="cov8" title="1">{
        return uc.repo.Delete(id)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
